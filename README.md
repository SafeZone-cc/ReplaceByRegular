# ReplaceByRegular

Скрипт для замены текста во множестве файлов согласно регулярным выражениям.

## Состав
 - Regular.txt - список замен
 - ReplaceByRegular.vbs - сам скрипт
 - Readme.txt - этот файл.

## Как пользоваться?

1) Копируете файл Regular.txt и ReplaceByRegular.vbs
в папку, где нужно рекурсивно (с подкаталогами) провести замены текста.

Текст может быть в кодировках:
- ANSI
- UTF-8 (в этом случае текст регулярки также должен быть в UTF-8 (без BOM))
- UTF-16 LE с BOM

2) Откройте Regular.txt (должен лежать рядом со скриптом).
Создайте перечень замен вида:

> word1=Что ищем1

> word2=Чем заменяем1

> word1=Что ищем2

> word2=Чем заменяем2

где каждому word1= соостветствует word2=, который под ним находится.
Так, Вы можете сделать одновременно несколько разных замен.

> word1= принимает для поиска регулярное выражение (писать после знака равенства).

> word2= принимает текст, на который будет произведена замена части, найденной регуляркой, указанной в word1=

3) Запускаем скрипт ReplaceByRegular.vbs

Отчет о заменах будет создан в виде файла Replace - log.log рядом со скриптом.

## Настройки

1) Список расширений

**Скрипт обрабатывает только файлы с расширениями, список которых указан в его шапке.**
Правый клик по файлу **ReplaceByRegular.vbs** -> **"Изменить"**
Смотрим сюда (строка 5):

`Dim Exts: Exts = "htm;html;txt"`

2) Замена с учетом регистра букв.
Если Вы хотите включить учёт регистра букв при поиске по регулярному выражению:
Правый клик по файлу **ReplaceByRegular.vbs** -> **"Изменить"**
Смотрим сюда (строка 11):

`Dim IgnoreCase: IgnoreCase = true`

и меняем true на false


## Примечания

В word2 действуют некоторые правила экранирования. Так:

\\ будет заменен на \

\^ будет заменен на ^

\$ будет заменен на $

\* будет заменен на *

\+ будет заменен на +

\? будет заменен на ?

\. будет заменен на .

\| будет заменен на |

\n будет заменен на новую строку

\r будет заменен на перевод каретки

\t будет заменен на знак табуляции

Также есть 2 специальные замены:

1) `$$$file$$$` будет заменено на имя файла (+ расширение имени), в котором найдена искомая фраза.

Например, если файл назывался my.txt
а шаблоны такие:

`word1=\<a href="default\.htm"\>`

`word2=<a href="$$$file$$$">`

то
`<a href="default.htm">`
будет заменено на:
`<a href="my.txt">`

2) `\@{{{utf8toANSI}}}`

означает, что искомая фраза будет перекодирована из кодировки utf-8 в ANSI,
где \@ - это подстановка искомой фразы.

Например, имеем текст в utf-8:

`<title>Привет, regist</title>`

После применения шаблона:

`word1=<title>[^<]*</title>`

`word2=\@{{{utf8toANSI}}}`

Результат будет ANSI-строка:

`<title>Привет, regist</title>`

3) `\@{{{ANSItoUTF8}}}`

означает, что искомая фраза будет перекодирована из кодировки ANSI в utf-8,
где \@ - это подстановка искомой фразы.

Например, имеем текст в ANSI:

`<title>Привет, regist</title>`

После применения шаблона:

`word1=<title>[^<]*</title>`

`word2="\@"{{{ANSItoUTF8}}}`

Результат будет UTF-8 строка (в кавычках):
`"<title>Привет, regist</title>"`

Обратите внимание, метка BOM автоматически не добавляется.
Некоторые редакторы могут неверно распознать исходный формат текстового файла.

Скрипт сподвигнул написать **regist**